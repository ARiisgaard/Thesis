\chapter{The code in the project}


\section{HTML and CSS}

\begin{lstlisting}[language=HTML5, caption={The HTML and CSS in the project}, label= VoresHTML,escapechar=|]

<!DOCTYPE html>
<html>

<head>
<meta charset="utf-8" />
<link rel="shortcut icon" href="#" />
<title>maps from geotiff</title>

<script src="./lib/plotty.min.js"></script>
<script src="./lib/geotiff.browserify.js"></script>

<script src="./lib/olGeoTiff.js"></script>
<script src="./lib/ol-debug.js"></script>
<link rel="stylesheet" href="./lib/ol-debug.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<style>
body {
font-family: Arial, sans-serif;
font-size: 14px;
}

.map {
width: 400px;
height: 400px;
margin-top: 20px;
}

.mapcontainer {
padding: 0 100px;
text-align: center;
}

td {
border: 0;
margin: 0
}

td.l {
color: white;
text-align: center;
width: 30px;
height: 30px;
padding: 0
}

@media (min-width: 900px) {
.wrapper {
display: flex;
}

.half {
padding: 0 10px;
width: 400px;
float: left;
}
}
</style>
</head>

<body>
<input type="text" id="requestedCity" value="Search">
<button onclick="SearchCity()"><i class="fa fa-search"></i></button>
<div class="wrapper">
<div class="half">
<h4 id="firstMapName">Map1</h4>
<div id="firstmap" class="map"></div>
</div>
<div class="half">
<h4 id="secondMapName">Map2</h4>
<div id="secondMap" class="map"></div>
</div>
</div>
<!-- Add legend -->
<table>
<tr>
<td colspan="6">Population per cell</td>
</tr>
<tr>
<td class='l' id='d0' title='0'></td>
<td class='l' id='d1' title='0'></td>
<td class='l' id='d2' title='0'></td>
<td class='l' id='d3' title='0'></td>
<td class='l' id='d4' title='0'></td>
<td class='l' id='d5' title='0'></td>
</tr>
<tr>
<td colspan="4" style='text-align: left'>0</td>
<td></td>
<td id="MaxValue" colspan="4" style='text-align: right'>0</td>
</tr>
</table>

<script src="tileMetadata.js"></script>
<script src="map.js"></script>

</body>

</html>

\end{lstlisting}


\section{Javascript}
\begin{lstlisting}[language=JavaScript, caption={The JavaScript for the map}, label= VoresJS,escapechar=|]

////////////
// Getting Metadata
////////////



//The folder, where the tiles are extracted from.
var tileFolders = ['g2tTiles', 'g2tSecondMap']

//Add layer names to map
document.getElementById('firstMapName').innerHTML = tileFolders[0]
document.getElementById('secondMapName').innerHTML = tileFolders[1]
//Get tile-metadata produced by gdal2tiles32 and store it in the tileMetadata object.
var tileMetadata = {};
getTileMetadata(tileMetadata, tileFolders);

//Resolutions from the metadata xmlfile creates issues with loading the correct file if any zoomlayers are excluded
//Therefore resolutions tables are created manually.
var resolutions = new Array(14);
var matrixIds = new Array(14);
for (var z = 0; z < 14; ++z) {
// generate resolutions and matrixIds arrays for this WMTS
//The number in the resolution calculation is the units-per-pixel value at zoomlayer 0 in the xml file generated by gdal2tiles
resolutions[z] = 0.03333333333514 / Math.pow(2, z);
matrixIds[z] = z;
}

////////////
// Creation of colorscale
////////////

//Here a color scale is created and added to the available color scales
//The colors are selected in colorbrewer - https://colorbrewer2.org/#type=sequential&scheme=OrRd&n=6
var colorScale = {};
colorScale.color_steps = [
'#fef0d9',
'#fdd49e',
'#fdbb84',
'#fc8d59',
'#e34a33',
'#b30000'
]
colorScale.percentage_steps = [
0,
0.2,
0.4,
0.6,
0.8,
1
]
plotty.addColorScale("sequentialMultiHue6Colors", colorScale.color_steps, colorScale.percentage_steps);

////////////
// Creating the map
////////////

// Setting map projection
const projection = new ol.proj.get('EPSG:4326');

//Create the layers with the raster tiles. Some metadata is collected from the metadta object
var wmslayerMap1 = new ol.layer.Tile({
source: new ol.source.WMTS({
url: tileFolders[0] + '/{TileMatrix}/{TileCol}/{TileRow}.tiff',
projection: projection,
tileGrid: new ol.tilegrid.WMTS({
origin: tileMetadata[tileFolders[0] + "origin"],
resolutions: resolutions,
matrixIds: matrixIds,
tileSize: 256
}),
requestEncoding: 'REST',
transition: 0
}),
//The extent has been limited, since there I didn't test with the raster for the entire world
extent: tileMetadata[tileFolders[0] + "boundingBox"],
opacity: 0.65
});

var wmslayerMap2 = new ol.layer.Tile({
source: new ol.source.WMTS({
url: tileFolders[1] + '/{TileMatrix}/{TileCol}/{TileRow}.tiff',
projection: projection,
tileGrid: new ol.tilegrid.WMTS({
origin: tileMetadata[tileFolders[1] + "origin"],
resolutions: resolutions,
matrixIds: matrixIds,
tileSize: 256
}),
requestEncoding: 'REST',
transition: 0
}),
extent: tileMetadata[tileFolders[1] + "boundingBox"],
opacity: 0.65
});

// define the base layer
var osmSource = new ol.source.OSM();
var osm = new ol.layer.Tile({
source: osmSource
});

// This view is shared between both maps, so they always show the same
var sharedView = new ol.View({
projection,
center: tileMetadata[tileFolders[0] + "center"],
zoom: 7,
maxZoom: 11,
minZoom: 2
})

// define the left map
var map = new ol.Map({
target: 'firstmap',
layers: [
osm, wmslayerMap1
],
wrapDateLine: true,
view: sharedView
});

// define the right map
var map2 = new ol.Map({
target: 'secondMap',
layers: [
osm, wmslayerMap2
],
wrapDateLine: true,
view: sharedView
});



// olGeoTiff setup
var olgt_map1 = new olGeoTiff(wmslayerMap1);
var olgt_map2 = new olGeoTiff(wmslayerMap2);
olgt_map1.plotOptions.palette = 'sequentialMultiHue6Colors';
olgt_map2.plotOptions.palette = 'sequentialMultiHue6Colors';

// Color the maps based on their values
recolorMap()


//Add the colors from the color palette to the legend
for (i = 0; i < colorScale.percentage_steps.length; i++) {
document.getElementById('d' + String(i)).style.background = colorScale.color_steps[i]
}

//Recolor map on movement or zoom
map.on("moveend", function() {
recolorMap()
});


////////////
// Recoloring the map
////////////
// Find the highest value currently displayed and recolor based on this

//variable for holding the max value and checking if the max value changes
var currentMax = 0;
var oldMax = currentMax;

function recolorMap() {

//Array holding max values for all currently displayed tiles
var maxValuesAllTiles = [];

//Getting map extent and zoom
var mapExtent = map.getView().calculateExtent(map.getSize())
var mapZoom = map.getView().getZoom();

//This variable is adjusting for the fact that the wrong zoom level is being loaded
var zoomlevelAdjustment = 3

//The loadExtent is the same as the mapextent, unless the mapextent shows an area outside the data area
// In this case the loadExtent gets reduced to the bounding box -
// this is to avoid attempt at loading data, which doesn't exist
var loadExtent = new Array(4);
loadExtent[0] = Math.max(mapExtent[0], tileMetadata[tileFolders[0] + "boundingBox"][0]);
loadExtent[1] = Math.max(mapExtent[1], tileMetadata[tileFolders[0] + "boundingBox"][1])
loadExtent[2] = Math.min(mapExtent[2], tileMetadata[tileFolders[0] + "boundingBox"][2])
loadExtent[3] = Math.min(mapExtent[3], tileMetadata[tileFolders[0] + "boundingBox"][3])

//Get the total number of tiles - both maps have the same number of tiles, so no need to run this twice
var tileNumber = 0;
wmslayerMap1.getSource().getTileGrid().forEachTileCoord(loadExtent, mapZoom - zoomlevelAdjustment, function(tileCoord) {
tileNumber++;
})

//Counting variables keeping track of how many tiles have been processed in each map
var currentTile = {};
currentTile[tileFolders[0]] = 0;
currentTile[tileFolders[1]] = 0;

//Calculate the highest value in each map. The counting variables have been included to know when to draw the layer
findHighestValue(wmslayerMap2, tileFolders[1], tileFolders[0])
findHighestValue(wmslayerMap1, tileFolders[0], tileFolders[1])

function findHighestValue(wmslayer, selfCounter, otherCounter) {

//Getting the url (name) of the tile based on its coordinates
var tileUrlFunction = wmslayer.getSource().getTileUrlFunction()

//Checks which tiles that currently are being displayed
//This is done at a lower resolution than the current zoomlevel, since loading otherwise would be too slow
wmslayer.getSource().getTileGrid().forEachTileCoord(loadExtent, mapZoom - zoomlevelAdjustment, function(tileCoord) {

//Gets the name of each currently displayed tile
tileName = tileUrlFunction(tileCoord, ol.proj.get('EPSG:4326'))
asyncCall()
async function asyncCall() {

//Get the maximum value in the tile and add it to the array
tileMaxValue = await calculateMaxValue(tileName);
maxValuesAllTiles.push(tileMaxValue)
//Update the counter - one more tile have been processed
currentTile[selfCounter]++;

//Checks if the function is finished with finding max value for tiles in both layers
if (currentTile[selfCounter] == tileNumber && currentTile[otherCounter] == tileNumber && tileNumber != 0) {

//Resets all counters and set current max to the highest value
currentTile[selfCounter] = 0;
currentTile[otherCounter] = 0;
tileNumber = 0;
currentMax = Math.max(...maxValuesAllTiles)
//Recolor the map, if max value have changed
if (Number.isInteger(currentMax) && currentMax != oldMax) {
oldMax = currentMax
olgt_map1.redraw(olgt_map1, currentMax, colorScale);
olgt_map2.redraw(olgt_map2, currentMax, colorScale);
}
}

}
})

}

}



//This function pans to a searched city.
function SearchCity() {
//Get the name from the search bar and request the coordinates for it from Nominatim
var cityName = document.getElementById("requestedCity").value;
var request = "https://nominatim.openstreetmap.org/search?q=" + cityName + "&format=geojson"

var xhttp = new XMLHttpRequest();

xhttp.onreadystatechange = function() {
if (this.readyState == 4 && this.status == 200) {
var cityData = JSON.parse(this.responseText)
var cityCoordinates = cityData.features[0].geometry.coordinates

map.getView().setCenter(cityCoordinates)
map.getView().setZoom(9)

}
}
xhttp.open("GET", request, true);
xhttp.send();

}

\end{lstlisting}

\begin{lstlisting}[language=JavaScript, caption={The JavaScript for getting Metadata about tiles}, label= VoresJS,escapechar=|]
//Making a request for the tileData - see function getTileMetadata
function getTileMetadata(objectWithMetadata, folderArray) {
for (i = 0; i < folderArray.length; i++)
{

var xhttp = new XMLHttpRequest();
xhttp.open("GET", folderArray[i] + "/tilemapresource.xml", false);
xhttp.send();
processTileMetadata(xhttp, objectWithMetadata, folderArray[i]);

}
}

//When gdal2tiles32.py is run it creates a xml file with metadata. This function extracts the relevant data
function processTileMetadata(xml, objectWithMetadata, folderName) {
var xmlDoc = xml.responseXML;
var parser = new DOMParser();
var xmlDoc = parser.parseFromString(xml.responseText, "application/xml");

//Getting the coordinates for bounding box, origin and center
var minx = parseFloat(xmlDoc.getElementsByTagName("BoundingBox")[0].attributes.minx.value);
var maxx = parseFloat(xmlDoc.getElementsByTagName("BoundingBox")[0].attributes.maxx.value);
var miny = parseFloat(xmlDoc.getElementsByTagName("BoundingBox")[0].attributes.miny.value);
var maxy = parseFloat(xmlDoc.getElementsByTagName("BoundingBox")[0].attributes.maxy.value);
objectWithMetadata[folderName + "boundingBox"] = [minx, miny, maxx, maxy]
objectWithMetadata[folderName + "origin"] = [minx, maxy]
objectWithMetadata[folderName + "center"] = [
(minx + maxx) / 2,
(miny + maxy) / 2
]

}
\end{lstlisting}


\begin{lstlisting}[language=JavaScript, caption={Additions to olGeoTiff.js. The original code can be found at \citet{olGeoTiffSource}}, label= VoresJS,escapechar=|]

//Everything above is the same as the original olGeoTiff file

olGeoTiff.prototype.redraw = function(map, currentMax, legendValues) {

map.plotOptions.domain = [0, currentMax];
this.layer.getSource().refresh();
updateLegend(legendValues, currentMax);
}


// Updates the legend
function updateLegend(colorValues, maxValue) {
//Updates the number displaying the maximum value
document.getElementById('MaxValue').innerHTML = maxValue;
//Updates the values shown, when holding the mouse over the individual color classes
for (i = 0; i < colorValues.percentage_steps.length; i++) {
document.getElementById('d' + String(i)).title = Math.round(colorValues.percentage_steps[i] * maxValue)
}
}

// This object contains the maximum value for the loaded tiles data
var maxValueTileData = {};

//Returns the maximum value for a given tile. In the value does not exist it will be calculated and added to the object
function calculateMaxValue(url) {
//The value gets returned as a asynchronous function, since it otherwise would return undefined
return new Promise(resolve => {

//If the tiles have previously been loaded and stored in the object, then it is returned
if (maxValueTileData[url]) {
resolve(maxValueTileData[url].maxValue)
}
//If the tile is not in the object, then it gets calculated, added to the object and then returned
else {
maxValueTileData[url] = {
maxValue: 0 //Edited
};

// send new request
var xhr = new XMLHttpRequest();
xhr.open('GET', url, true);
xhr.responseType = 'arraybuffer';

// setup the async function that is executed AFTER the tile was loaded
xhr.onloadend = function(e) {
if (xhr.status == 200) {
// save rasters of parsed tiff
var parsed = GeoTIFF.parse(this.response);
var raster = parsed.getImage().readRasters();
// calculate the maximum value in the tile
var maxPop = Math.max(...raster[0])

//Add to the object and return the value
maxValueTileData[url].maxValue = maxPop
resolve(maxValueTileData[url].maxValue)
}
//
//       // send ajax request
}
xhr.send();

}

})
}
\end{lstlisting}



