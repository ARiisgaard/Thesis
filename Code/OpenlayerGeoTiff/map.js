const projection = ol.proj.get('EPSG:4326');

////////////
// Getting Metadata
////////////

//Get tile-metadata produced by gdal2tiles32 and store it in the tileMetadata object. Necessary to ensure correct resolutions among other things
var tileMetadata = {};

//The folder, where the tiles are extracted from. Locally it can be "g2tTiles" for India or "newTestTiles" for the States
tileMetadata.tileFolder = 'g2tTiles';
getTileMetadata(tileMetadata);

////////////

//Resolutions from the metadata xmlfile creates issues with loading the correct file if any zoomlayers are excluded
//Therefore resolutions tables are created manually.
var resolutions = new Array(14);
var matrixIds = new Array(14);
for (var z = 0; z < 14; ++z) {
  // generate resolutions and matrixIds arrays for this WMTS
  //The number in the resolution calculation is the units-per-pixel value at zoomlayer 0 in the xml file generated by gdal2tiles
  resolutions[z] = 0.03333333333514 / Math.pow(2, z);
  matrixIds[z] = z;
}

//Creating the layer with population data. Seperated into three variables, because they are called individually to apply the coloring
var tileGrid = new ol.tilegrid.WMTS({origin: tileMetadata.origin, resolutions: resolutions, matrixIds: matrixIds, tileSize: 256})

var tileSource = new ol.source.WMTS({
  // url: 'http://webportals.ipsl.jussieu.fr/ScientificApps/dev/forge_patrick/eox/tileSet/{TileMatrix}/{TileRow}/{TileCol}.tif',
  url: tileMetadata.tileFolder + '/{TileMatrix}/{TileCol}/{TileRow}.tiff',
  projection: projection,
  tileGrid: tileGrid,
  requestEncoding: 'REST',
  transition: 0
})

var wmslayer = new ol.layer.Tile({
  source: tileSource, extent: tileMetadata.boundingBox //The extent has been limited, since there I didn't test with the raster for the entire world
});

// define the base layer
var osmSource = new ol.source.OSM();
var osm = new ol.layer.Tile({
  source: osmSource
  // , extent: tileMetadata.boundingBox
});

// define the map
var map = new ol.Map({
  target: 's2map',
  layers: [
    osm, wmslayer
  ],
  wrapDateLine: true,
  view: new ol.View({projection, center: tileMetadata.center, zoom: 7, maxZoom: 11, minZoom: 2}),
  controls: ol.control.defaults({
    attributionOptions: {
      collapsible: false
    }
  })
});

//Creation of colorscale

var colorScale = {};
colorScale.color_steps = [
  '#fef0d9',
  '#fdd49e',
  '#fdbb84',
  '#fc8d59',
  '#e34a33',
  '#b30000'
]
colorScale.percentage_steps = [
  0,
  0.2,
  0.4,
  0.6,
  0.8,
  1
]
plotty.addColorScale("sequentialMultiHue6Colors", colorScale.color_steps, colorScale.percentage_steps);

// olGeoTiff setup
var olgt_map = new olGeoTiff(wmslayer);
olgt_map.plotOptions.domain = [0, 2000];
olgt_map.plotOptions.noDataValue = -9999;
olgt_map.plotOptions.palette = 'sequentialMultiHue6Colors';

// handle user input
$(window).on('load', function() {
  recolorMap()

  //Add the colors from the color palette to the legend
  for (i = 0; i < colorScale.percentage_steps.length; i++) {
    document.getElementById('d' + String(i)).style.background = colorScale.color_steps[i]
  }

  var $container = $('#s2map').parent();

  // slider2 (opacity)
  var slider2 = $container.find('.opacityslider')[0];

  var opacity = 0.7;
  noUiSlider.create(slider2, {
    start: opacity,
    connect: true,
    range: {
      'min': 0,
      'max': 1
    },
    tooltips: true
  });
  wmslayer.setOpacity(opacity);

  slider2.noUiSlider.on('slide', function(values) {
    wmslayer.setOpacity(values[0] * 1);
  });
  var Uppervalue = 0;

  //Recolor map on movement or zoom
  map.on("moveend", function() {
    recolorMap()
  });

});

// Find the highest value currently displayed and recolor based on this
var currentMax = 0;
function recolorMap() {

  var mapExtent = map.getView().calculateExtent(map.getSize())

  //This variable should potentially be deleted later, if the extent get limited to the boundingBox of the layer
  //The loadExtent is the same as the mapextent, unless the mapextent shows an area outside the data area
  //- In this case the loadExtent gets reduced to the bounding box - this is to avoid attempt at loading data, which doesn't exist
  var loadExtent = new Array(4);
  loadExtent[0] = Math.max(mapExtent[0], tileMetadata.boundingBox[0]);
  loadExtent[1] = Math.max(mapExtent[1], tileMetadata.boundingBox[1])
  loadExtent[2] = Math.min(mapExtent[2], tileMetadata.boundingBox[2])
  loadExtent[3] = Math.min(mapExtent[3], tileMetadata.boundingBox[3])

  var mapZoom = map.getView().getZoom();

  //Function for getting the url/filename for tiles based on their coordinates
  var tileUrlFunction = tileSource.getTileUrlFunction()
  var currentTiles = [];
  //Checks which tiles that currently are being displayed
  //This is done at a lower resolution than the current zoomlevel, since loading otherwise would be too slow
  tileSource.tileGrid.forEachTileCoord(loadExtent, mapZoom - 3, function(tileCoord) {

    //Gets the name of each currently displayed tile
    tileName = tileUrlFunction(tileCoord, ol.proj.get('EPSG:4326'))
    currentTiles.push(tileName);

  })

  bigValues = [];

  var waiting = currentTiles.length;
  // Calculate tbe max value for each tiles

  //This step happens too soon
  currentTiles.forEach((tile) => {
    bigValues.push(calculateMaxValue(tile))
    finish()
  })

  function finish() {
    waiting--;
    if (waiting == 0) {
      console.log("It is here")
      console.log({bigValues})
      currentMax = Math.max(...bigValues)
      if (Number.isInteger(currentMax)) {

        olgt_map.redraw(olgt_map, currentMax, colorScale);
      }
    }
  }

}