const projection = ol.proj.get('EPSG:4326');

////////////
// Getting Metadata
////////////

//Get tile-metadata produced by gdal2tiles32 and store it in the tileMetadata object. Necessary to ensure correct resolutions among other things
var tileMetadata = {};

//The folder, where the tiles are extracted from. Locally it can be "g2tTiles" for India or "newTestTiles" for the States
tileMetadata.tileFolder = 'g2tTiles';
getTileMetadata(tileMetadata);

////////////

//Resolutions from the metadata xmlfile creates issues with loading the correct file if any zoomlayers are excluded
//Therefore resolutions tables are created manually.
var resolutions = new Array(14);
var matrixIds = new Array(14);
for (var z = 0; z < 14; ++z) {
  // generate resolutions and matrixIds arrays for this WMTS
  //The number in the resolution calculation is the units-per-pixel value at zoomlayer 0 in the xml file generated by gdal2tiles
  resolutions[z] = 0.03333333333514 / Math.pow(2, z);
  matrixIds[z] = z;
}

//Creating the layer with population data. Seperated into three variables, because they are called individually to apply the coloring
var tileGrid = new ol.tilegrid.WMTS({origin: tileMetadata.origin, resolutions: resolutions, matrixIds: matrixIds, tileSize: 256})

var tileSource = new ol.source.WMTS({
  // url: 'http://webportals.ipsl.jussieu.fr/ScientificApps/dev/forge_patrick/eox/tileSet/{TileMatrix}/{TileRow}/{TileCol}.tif',
  url: tileMetadata.tileFolder + '/{TileMatrix}/{TileCol}/{TileRow}.tiff',
  projection: projection,
  tileGrid: tileGrid,
  requestEncoding: 'REST',
  transition: 0
})

var wmslayer = new ol.layer.Tile({
  source: tileSource, extent: tileMetadata.boundingBox //The extent has been limited, since there I didn't test with the raster for the entire world
});

// define the base layer
var osmSource = new ol.source.OSM();
var osm = new ol.layer.Tile({
  source: osmSource
  // , extent: tileMetadata.boundingBox
});

// define the map
var map = new ol.Map({
  target: 's2map',
  layers: [
    osm, wmslayer
  ],
  wrapDateLine: true,
  view: new ol.View({projection, center: tileMetadata.center, zoom: 7, maxZoom: 11, minZoom: 2}),
  controls: ol.control.defaults({
    attributionOptions: {
      collapsible: false
    }
  })
});

//Creation of colorscale

var colorScale = {};
colorScale.color_steps = [
  '#fef0d9',
  '#fdd49e',
  '#fdbb84',
  '#fc8d59',
  '#e34a33',
  '#b30000'
]
colorScale.percentage_steps = [
  0,
  0.2,
  0.4,
  0.6,
  0.8,
  1
]
plotty.addColorScale("sequentialMultiHue6Colors", colorScale.color_steps, colorScale.percentage_steps);

// olGeoTiff setup
var olgt_map = new olGeoTiff(wmslayer);
olgt_map.plotOptions.domain = [0, 2000];
olgt_map.plotOptions.noDataValue = -9999;
olgt_map.plotOptions.palette = 'sequentialMultiHue6Colors';

// handle user input
$(window).on('load', function() {
  recolorMap()

  //Add the colors from the color palette to the legend
  for (i = 0; i < colorScale.percentage_steps.length; i++) {
    document.getElementById('d' + String(i)).style.background = colorScale.color_steps[i]
  }

  var $container = $('#s2map').parent();

  // slider2 (opacity)
  var slider2 = $container.find('.opacityslider')[0];

  var opacity = 0.7;
  noUiSlider.create(slider2, {
    start: opacity,
    connect: true,
    range: {
      'min': 0,
      'max': 1
    },
    tooltips: true
  });
  wmslayer.setOpacity(opacity);

  slider2.noUiSlider.on('slide', function(values) {
    wmslayer.setOpacity(values[0] * 1);
  });
  var Uppervalue = 0;

  //Recolor map on movement or zoom
  map.on("moveend", function() {
    recolorMap()
  });

});

// Find the highest value currently displayed and recolor based on this
var currentMax = 0;
function recolorMap() {
  var maxValues = [];

  var mapExtent = map.getView().calculateExtent(map.getSize())

  //This variable should potentially be deleted later, if the extent get limited to the boundingBox of the layer
  //The loadExtent is the same as the mapextent, unless the mapextent shows an area outside the data area
  //- In this case the loadExtent gets reduced to the bounding box - this is to avoid attempt at loading data, which doesn't exist
  var loadExtent = new Array(4);
  loadExtent[0] = Math.max(mapExtent[0], tileMetadata.boundingBox[0]);
  loadExtent[1] = Math.max(mapExtent[1], tileMetadata.boundingBox[1])
  loadExtent[2] = Math.min(mapExtent[2], tileMetadata.boundingBox[2])
  loadExtent[3] = Math.min(mapExtent[3], tileMetadata.boundingBox[3])

  var mapZoom = map.getView().getZoom();

  //Function for getting the url/filename for tiles based on their coordinates
  var tileUrlFunction = tileSource.getTileUrlFunction()
  var currentTiles = [];
  // var maxValues = [];
  //Checks which tiles that currently are being displayed
  //This is done at a lower resolution than the current zoomlevel, since loading otherwise would be too slow
  tileSource.tileGrid.forEachTileCoord(loadExtent, mapZoom - 3, function(tileCoord) {

    //Gets the name of each currently displayed tile
    tileName = tileUrlFunction(tileCoord, ol.proj.get('EPSG:4326'))
    // currentTiles.push(tileName);
    // calculateMaxValue(tileName).then( function(result) {
    //   console.log(result)
    // } )
    asyncCall()
    async function asyncCall() {
    
    // maxValues.push(calculateMaxValue(tileName))
    tileMaxValue = await calculateMaxValue(tileName);
    maxValues.push(tileMaxValue)
    // console.log(value2)
  }
  })
  async2Call()
  console.log(maxValues)
  
  function resolveAfter2Seconds() {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(maxValues);
    }, 1000);
  });
}
async function async2Call() {
  const result = await resolveAfter2Seconds();
  // currentMax = Math.max(...maxValues)
  currentMax = Math.max(...result)
    
  console.log(currentMax)
  if (Number.isInteger(currentMax)) {
  
    olgt_map.redraw(olgt_map, currentMax, colorScale);
  }  
}
}

// map.on('postrender', function(event) {
//   // console.log(maxValues)
//   currentMax = Math.max(...maxValues)
//   if (Number.isInteger(currentMax)) {
// 
//     olgt_map.redraw(olgt_map, currentMax, colorScale);
// }
// }
// );




function SearchCity(){
  var cityName = document.getElementById("requestedCity").value;
  var request = "https://nominatim.openstreetmap.org/search?q="+cityName+"&format=geojson"
  var mapZoom = map.getView().getZoom();
  
  var xhttp = new XMLHttpRequest();
  
  xhttp.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
          var cityData = JSON.parse(this.responseText)
          var cityCoordinates = cityData.features[0].geometry.coordinates
          
          console.log({cityCoordinates})

          map.getView().setCenter(cityCoordinates)
          map.getView().setZoom(9)
          
    //       map.setView(new ol.View({
    // center: [75.8681996, 22.7203616],
    // zoom: mapZoom
    // }));

        }
      }
      xhttp.open("GET", request, true);
      xhttp.send();
      

}



